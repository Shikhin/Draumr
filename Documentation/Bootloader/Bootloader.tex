\documentclass[a4paper,oneside]{memoir}

\usepackage{hyperref}
\hypersetup{pdfborder={0 0 0}}

\usepackage{dirtree}

\begin{document}

% Title.
\title{Bootloader\\\small Preliminary Draft}
\author{Shikhin \textsc{Sethi}}
\maketitle

\clearpage

\tableofcontents

\chapter{Introduction}

The following chapter provides an introduction to the bootloader for the Draumr project.

\section{Background}

The Multiboot Specification has helped kernel developers avoid meddling into the realm of bootloaders. The only viable implementation of the Multiboot Specification, the GNU GRand Unified Bootloader (GRUB)\footnote{Other implementations, such as the mboot.c32 module for Syslinux, and kboot, exist, but are not as widely used as GRUB.}, on the other hand, is more widely used for its implementation of the Linux boot protocol than the Multiboot Specification. Furthermore, the Free Software Foundation (FSF) has shown poor interest in the development of the Specification, and there was a gap of more than \emph{five} years between the last release of GRUB Legacy, GRUB 0.97, and release of the Multiboot Specification version 1.6. Both versions of GRUB also employ several poor mechanisms\footnote{An example of this is the fact that GRUB does not verify, or sanitize the memory-map it passes to the kernel. It furthermore utiilizes the worst, yet simplest, firmware functions to generate this memory-map.} and makes extension of the bootloader to different firmwares difficult.

The necessity for a customized bootloader for Draumr arises with this lack of a good Multiboot Specification, and the author aims at targetting all shortcoming of both, the standard and the implementation, with the presented bootloader.

\section{Terminology}

\subsection{\emph{Not} a boot-manager}

Another discrepancy that GRUB introduces is the difference between a bootloader and a boot-manager. A boot-\emph{manager}, as the name suggests, is supposed to exist for the convenience of the user, to help him manage the loading of all Operating Systems (OSs) present on disk. A boot\emph{loader}, on the other hand, only aims at initializing the environment for the kernel to take control.

GRUB aims at being the master of all jacks, by attempting to serve both as a boot-manager and a bootloader. The bootloader for Draumr clearly differentiates between the two, and offers no boot-manager capabilities. Furthermore, no such boot-manager is planned to be developed under the Draumr umbrella-head.

\subsection{\emph{Not} a boot-sector}

A boot-sector is ``the region of a hard disk, floppy disk, optical disc, or other data storage device that contains machine code to be loaded into random-access memory (RAM) by a computer system's built-in firmware," and thus, is where the bootloader starts its initialization. The bootloader, on the other hand, encompasses all stages that assume control before the kernel is initiated. 

\emph{Boot-code} is used interchangeably with the term \emph{bootloader} in the documentation. 

\section{Target architectures}

The bootloader aligns with the rest of the project, and targets the \texttt{x86} and the \texttt{x86\_64} architectures.

\section{Target firmwares}

The bootloader aims at being extensible, such as to adopt any new firmware developed for the targetted architectures. As of date, the implementation targets both legacy BIOS, and UEFI firmwares.

\section{Target kernels}

The bootloader is heavily customized for the Draumr project kernels, and thus, does not boast of being either generic or usable for other OS projects. It can, however, serve as inspiration to those wanting to develop a replacement for the Multiboot Specification, and can also provide suitable paradigms for a proper bootloader.

\section{Target boot devices}

The bootloader currently supports the following as boot devices:

\begin{itemize}
    \item 3.5" floppy.
    \item El-Torito ISO.
    \item PXE.
    \item Hard-disk (MBR).
    \item Hard-disk (GPT).
\end{itemize}

The bootloader also makes it easy to write new modules, to add support for boot devices per demand.

\section{Implementation}

The implementation of the bootloader is contained in \texttt{\href{run:./../../Bootloader/}{Bootloader/}}.

\chapter{Overview}

The following chapter aims at providing a brief overview of the bootloader, and its components.

\section{Generic Overview}
\label{sec:Generic Overview}

The bootloader builds on the standard two-stage design, and separates the stages as:

\begin{description}
    \item[Stage 1] is demarcated as the \emph{firmware specific}, and \emph{boot device specific} stage. This stage thus varies for all boot devices as well firmwares supported. The stage provides a disk access interface, as well as all data that is supposed to be provided by the firmware.

    \item[Stage 2] is demarcated as the \emph{firmware independent}, and \emph{boot device independent} stage. This stage remains common for all supported boot devices, and firmwares. It handles all the generic boot tasks, such as parsing and cleaning of memory map, deciding of an efficient memory mode, et cetera. 

    This stage is known as the Boot Abstraction Layer, abbreviated to \textbf{BAL}.

    \item[Loader] is the last stage of the boot-code, and it initiates the environment for the specific \texttt{x86} or \texttt{x86\_64} kernel, passing control to it.
\end{description}

\section{BIOS Overview}

When BIOS serves as the firmware, Stage 1 as specified in \hyperref[sec:Generic Overview]{Section \ref*{sec:Generic Overview}, Generic Overview} gets split into:

\begin{description}
    \item[Stage 1] here is demarcated as the \emph{firmware specific}, and \emph{boot device specific} stage. This stage varies for all boot devices support. The stage provides a disk access interface to the next stage.

    \item[Stage 1.5]  is demarcated as the \emph{firmware specific}, and \emph{boot device independent} stage. This stage remains common for machines where BIOS serves as the firmware. The stage organizes all data that is supposed to be provided by the firmware, for the next stages.
\end{description}

\section{UEFI Overview}

When UEFI serves as the firmware, the design remains same as described in \hyperref[sec:Generic Overview]{Section \ref*{sec:Generic Overview}, Generic Overview}.

\chapter{Documentation}

The following chapter illustrates how the documentation for the bootloader has been split and written.

\section{Tree}

The documentation for the bootloader is divided as follows, where each file represents the component it is named after:\\

\dirtree{%
    .1 Documentation/Bootloader.
    .2 Bootloader.pdf.
    .2 BIOS.
    .3 Stage1.pdf.
    .3 Stage15.pdf.
    .2 UEFI.
    .3 Stage1.pdf.
    .2 BAL.pdf.
    .2 Loader.pdf.
}

\section{Structure}

Documentation for each component follows the same standard form, defined as:

\subsection{Overview}

This gives a brief overview of the component, and where the corresponding source code lies.

\subsection{Imported}

\begin{enumerate}
    \item CPU state. This explains the state the component expects the CPU to be in.
    \item Memory state. This explains the state the component expects the memory to be in.
    \item Hardware state. This explains the state the component expects the hardware to be in.
    \item API. This explains the API the component imports.
\end{enumerate}

\subsection{Exported}

\begin{enumerate}
    \item CPU state. This explains the state the component leaves the CPU in.
    \item Memory state. This explains the state the component leaves the memory in.
    \item Hardware state. This explains the state the component leaves the hardware in.
   \item API. This explains the API the component exports.
\end{enumerate}

\end{document}